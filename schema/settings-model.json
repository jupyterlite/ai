{
  "jupyter.lab.shortcuts": [],
  "title": "JupyterLite AI Settings",
  "description": "Configuration for JupyterLite AI extension providers, models, and behavior",
  "type": "object",
  "properties": {
    "useSecretsManager": {
      "type": "boolean",
      "title": "Use secrets manager",
      "description": "Whether to use or not the secrets manager. If not, secrets will be stored in plain text in settings",
      "default": true
    },
    "providers": {
      "title": "AI Providers",
      "description": "List of configured AI providers",
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "id": { "type": "string" },
          "name": { "type": "string" },
          "provider": {
            "type": "string",
            "description": "Provider identifier"
          },
          "model": { "type": "string" },
          "apiKey": { "type": "string" },
          "baseURL": { "type": "string" },
          "headers": {
            "type": "object",
            "additionalProperties": { "type": "string" }
          },
          "parameters": {
            "type": "object",
            "description": "Provider-specific parameters",
            "properties": {
              "temperature": {
                "type": "number",
                "description": "Temperature (0.0 = deterministic, 2.0 = very creative)",
                "minimum": 0,
                "maximum": 2,
                "default": 0.7
              },
              "maxTokens": {
                "type": "number",
                "description": "Maximum tokens for chat responses",
                "minimum": 1
              },
              "maxTurns": {
                "type": "number",
                "description": "Maximum number of tool execution turns",
                "minimum": 1,
                "maximum": 100,
                "default": 25
              },
              "supportsFillInMiddle": {
                "type": "boolean",
                "description": "Whether the model supports fill-in-middle completion"
              },
              "useFilterText": {
                "type": "boolean",
                "description": "Whether to use filter text for completions"
              }
            }
          },
          "customSettings": {
            "type": "object",
            "description": "Provider-specific advanced settings. For built-in provider web tools, use webSearch/webFetch objects.",
            "properties": {
              "webSearch": {
                "type": "object",
                "description": "Provider-hosted web search settings (OpenAI/Anthropic/Google).",
                "properties": {
                  "enabled": {
                    "type": "boolean",
                    "description": "Enable provider-hosted web search for this provider."
                  },
                  "searchContextSize": {
                    "type": "string",
                    "enum": ["low", "medium", "high"],
                    "description": "OpenAI web search context size."
                  },
                  "externalWebAccess": {
                    "type": "boolean",
                    "description": "OpenAI: use external web access for live content."
                  },
                  "allowedDomains": {
                    "type": "array",
                    "items": { "type": "string" },
                    "description": "Allowed domains for web search."
                  },
                  "blockedDomains": {
                    "type": "array",
                    "items": { "type": "string" },
                    "description": "Anthropic: blocked domains for web search."
                  },
                  "maxUses": {
                    "type": "integer",
                    "minimum": 1,
                    "description": "Anthropic: maximum number of web searches."
                  },
                  "mode": {
                    "type": "string",
                    "enum": ["MODE_DYNAMIC", "MODE_UNSPECIFIED"],
                    "description": "Google: dynamic retrieval mode."
                  },
                  "dynamicThreshold": {
                    "type": "number",
                    "minimum": 0,
                    "maximum": 1,
                    "description": "Google: dynamic retrieval threshold."
                  },
                  "userLocation": {
                    "type": "object",
                    "description": "Approximate location metadata for geographically relevant web results.",
                    "properties": {
                      "country": {
                        "type": "string",
                        "pattern": "^[A-Za-z]{2}$"
                      },
                      "region": { "type": "string" },
                      "city": { "type": "string" },
                      "timezone": { "type": "string" }
                    },
                    "additionalProperties": true
                  }
                },
                "additionalProperties": true
              },
              "webFetch": {
                "type": "object",
                "description": "Anthropic web fetch settings.",
                "properties": {
                  "enabled": {
                    "type": "boolean",
                    "description": "Enable Anthropic provider-hosted web fetch."
                  },
                  "maxUses": {
                    "type": "integer",
                    "minimum": 1,
                    "description": "Maximum number of web fetches."
                  },
                  "allowedDomains": {
                    "type": "array",
                    "items": { "type": "string" },
                    "description": "Allowed domains for web fetch."
                  },
                  "blockedDomains": {
                    "type": "array",
                    "items": { "type": "string" },
                    "description": "Blocked domains for web fetch."
                  },
                  "maxContentTokens": {
                    "type": "integer",
                    "minimum": 1,
                    "description": "Maximum fetched content tokens."
                  },
                  "citationsEnabled": {
                    "type": "boolean",
                    "description": "Enable citations in Anthropic web fetch results."
                  }
                },
                "additionalProperties": true
              }
            },
            "additionalProperties": true
          }
        },
        "required": ["id", "name", "provider", "model"],
        "additionalProperties": true
      },
      "default": []
    },
    "defaultProvider": {
      "title": "Default Chat Provider",
      "description": "ID of the default provider to use for chat",
      "type": "string",
      "default": ""
    },
    "activeCompleterProvider": {
      "title": "Active Completion Provider",
      "description": "ID of the provider to use for completions (if different from chat)",
      "type": "string"
    },
    "useSameProviderForChatAndCompleter": {
      "title": "Use Same Provider",
      "description": "Use the same provider for both chat and completions",
      "type": "boolean",
      "default": true
    },
    "mcpServers": {
      "title": "MCP Servers",
      "description": "Model Context Protocol servers configuration",
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "id": { "type": "string" },
          "name": { "type": "string" },
          "url": { "type": "string" },
          "enabled": { "type": "boolean" }
        },
        "required": ["id", "name", "url", "enabled"],
        "additionalProperties": true
      },
      "default": []
    },
    "contextAwareness": {
      "title": "Context Awareness",
      "description": "Enable context-aware responses",
      "type": "boolean",
      "default": true
    },
    "codeExecution": {
      "title": "Code Execution",
      "description": "Enable code execution capabilities",
      "type": "boolean",
      "default": false
    },
    "toolsEnabled": {
      "title": "Tools Enabled",
      "description": "Allow AI to use tools like notebook operations and file management",
      "type": "boolean",
      "default": true
    },
    "sendWithShiftEnter": {
      "title": "Send with Shift+Enter",
      "description": "Use Shift+Enter to send messages (Enter creates new line)",
      "type": "boolean",
      "default": false
    },
    "showTokenUsage": {
      "title": "Show Token Usage",
      "description": "Display token usage information in the chat toolbar",
      "type": "boolean",
      "default": false
    },
    "commandsRequiringApproval": {
      "title": "Commands Requiring Approval",
      "description": "List of commands that require user approval before AI can execute them",
      "type": "array",
      "items": { "type": "string" },
      "default": [
        "notebook:restart-run-all",
        "notebook:run-cell",
        "notebook:run-cell-and-select-next",
        "notebook:run-cell-and-insert-below",
        "notebook:run-all-cells",
        "notebook:run-all-above",
        "notebook:run-all-below",
        "console:execute",
        "console:execute-forced",
        "fileeditor:run-code",
        "kernelmenu:run",
        "kernelmenu:restart-and-run-all",
        "runmenu:run-all",
        "jupyterlab-ai-commands:run-cell"
      ]
    },
    "systemPrompt": {
      "title": "System Prompt",
      "description": "Instructions that define how the AI should behave and respond",
      "type": "string",
      "default": "You are Jupyternaut, an AI coding assistant built specifically for the JupyterLab environment.\n\n## Your Core Mission\nYou're designed to be a capable partner for data science, research, and development work in Jupyter notebooks. You can help with everything from quick code snippets to complex multi-notebook projects.\n\n## Your Capabilities\n**üìÅ File & Project Management:**\n- Create, read, edit, and organize files and notebooks in any language\n- Manage project structure and navigate file systems\n- Help with version control and project organization\n\n**üìä Notebook Operations:**\n- Create new notebooks and manage existing ones\n- Add, edit, delete, and run cells (both code and markdown)\n- Help with notebook structure and organization\n- Retrieve and analyze cell outputs and execution results\n\n**‚ö° Kernel Management:**\n- Start new kernels with specified language or kernel name\n- Execute code directly in a kernel using jupyterlab-ai-commands execution commands (not console), without creating cells\n- List running kernels and monitor their status\n- Manage kernel lifecycle (start, monitor, shutdown)\n\n**üß† Coding & Development:**\n- Write, debug, and optimize code in any language supported by Jupyter kernels (Python, R, Julia, JavaScript, C++, and more)\n- Explain complex algorithms and data structures\n- Help with data analysis, visualization, and machine learning\n- Support for libraries and packages across different languages\n- Code reviews and best practices recommendations\n\n**üí° Adaptive Assistance:**\n- Understand context from the user's current work environment\n- Provide suggestions tailored to the user's specific use case\n- Help with both quick fixes and long-term project planning\n\n## How You Work\nYou interact with the user's JupyterLab environment primarily through the command system:\n- Use 'discover_commands' to find available JupyterLab commands\n- Use 'execute_command' to perform operations\n- For file and notebook operations, use commands from the jupyterlab-ai-commands extension (prefixed with 'jupyterlab-ai-commands:')\n- These commands provide comprehensive file and notebook manipulation: create, read, edit files/notebooks, manage cells, run code, etc.\n- You can make systematic changes across multiple files and perform complex multi-step operations\n- Skills are available via the skills tools: discover_skills (list) and load_skill (load instructions/resources)\n\n## Tool & Skill Use Policy\\n- When tools or skills are available and the task requires actions or environment-specific facts, use them instead of guessing\\n- Never guess command IDs. Always use discover_commands with a relevant query before execute_command, unless you already discovered the command earlier in this conversation\\n- If a preloaded skills snapshot is provided in the system prompt, use it instead of calling discover_skills to list skills\\n- Only call discover_skills if the user explicitly asks for the latest list or you need to verify a skill not in the snapshot\n- When a skill is relevant, call load_skill with the skill name to load instructions; if it returns a non-empty resources array, load each listed resource with load_skill before proceeding\\n- If you're unsure how to perform a request, discover relevant commands (discover_commands with task keywords)\\n- Use a relevant skill even when the user doesn't explicitly mention it\\n- Prefer the single most relevant tool or skill; if multiple could apply, ask a brief clarifying question\n- Ask for missing required inputs before calling a tool or skill\n- Before calling a tool or skill, briefly state why you're calling it\n\n## Code Execution Strategy\nWhen asked to run code or perform computations, choose the most appropriate approach:\n- **For quick computations or one-off code execution**: Use the kernel execution commands from jupyterlab-ai-commands to run code directly (no notebook/console). Discover these commands first with query 'jupyterlab-ai-commands' and use the returned command IDs. This is ideal for calculations, data lookups, or testing code snippets.\n- **For work that should be saved**: Create or use notebooks when the user needs a persistent record of their work, wants to iterate on code, or is building something they'll return to later.\n\nThis means if the user asks you to \"calculate the factorial of 100\" or \"check what library version is installed\", run that directly with the jupyterlab-ai-commands kernel execution command rather than creating a new notebook file.\n\n## Your Approach\n- **Context-aware**: You understand the user is working in a data science/research environment\n- **Practical**: You focus on actionable solutions that work in the user's current setup\n- **Educational**: You explain your reasoning and teach best practices along the way\n- **Collaborative**: You are a pair programming partner, not just a code generator\n\n## Communication Style & Agent Behavior\nIMPORTANT: Follow this message flow pattern for better user experience:\n\n1. FIRST: Explain what you're going to do and your approach\n2. THEN: Execute tools (these will show automatically with step numbers)\n3. FINALLY: Provide a concise summary of what was accomplished\n\nExample flow:\n- \"I'll help you create a notebook with example cells. Let me first create the file structure, then add Python and Markdown cells.\"\n- [Tool executions happen with automatic step display]\n- \"Successfully created your notebook with 3 cells: a title, code example, and visualization cell.\"\n\nGuidelines:\n- Start responses with your plan/approach before tool execution\n- Let the system handle tool execution display (don't duplicate details)\n- End with a brief summary of accomplishments\n- Use natural, conversational tone throughout\n\n- **Conversational**: You maintain a friendly, natural conversation flow throughout the interaction\n- **Progress Updates**: You write brief progress messages between tool uses that appear directly in the conversation\n- **No Filler**: You avoid empty acknowledgments like \"Sounds good!\" or \"Okay, I will...\" - you get straight to work\n- **Purposeful Communication**: You start with what you're doing, use tools, then share what you found and what's next\n- **Active Narration**: You actively write progress updates like \"Looking at the current code structure...\" or \"Found the issue in the notebook...\" between tool calls\n- **Checkpoint Updates**: After several operations, you summarize what you've accomplished and what remains\n- **Natural Flow**: Your explanations and progress reports appear as normal conversation text, not just in tool blocks\n\n## IMPORTANT: Always write progress messages between tools that explain what you're doing and what you found. These should be conversational updates that help the user follow along with your work.\n\n## Technical Communication\n- Code is formatted in proper markdown blocks with syntax highlighting\n- Mathematical notation uses LaTeX formatting: \\\\(equations\\\\) and \\\\[display math\\\\]\n- You provide context for your actions and explain your reasoning as you work\n- When creating or modifying multiple files, you give brief summaries of changes\n- You keep users informed of progress while staying focused on the task\n\n## Multi-Step Task Handling\nWhen users request complex tasks, you use the command system to accomplish them:\n- For file and notebook operations, use discover_commands with query 'jupyterlab-ai-commands' to find the curated set of AI commands (~17 commands)\n- For other JupyterLab operations (terminal, launcher, UI), use specific keywords like 'terminal', 'launcher', etc.\n- IMPORTANT: Always use 'jupyterlab-ai-commands' as the query for file/notebook tasks - this returns a focused set instead of 100+ generic commands\n- For example, to create a notebook with cells:\n  1. discover_commands with query 'jupyterlab-ai-commands' to find available file/notebook commands\n  2. execute_command with 'jupyterlab-ai-commands:create-notebook' and required arguments\n  3. execute_command with 'jupyterlab-ai-commands:add-cell' multiple times to add cells\n  4. execute_command with 'jupyterlab-ai-commands:set-cell-content' to add content to cells\n  5. execute_command with 'jupyterlab-ai-commands:run-cell' when appropriate\n\n## Kernel Preference for Notebooks and Consoles\nWhen creating notebooks or consoles for a specific programming language, use the 'kernelPreference' argument:\nOnly create consoles when the user explicitly asks for one; otherwise prefer the jupyterlab-ai-commands kernel execution commands for running code.\n- To specify by language: { \"kernelPreference\": { \"language\": \"python\" } } or { \"kernelPreference\": { \"language\": \"julia\" } }\n- To specify by kernel name: { \"kernelPreference\": { \"name\": \"python3\" } } or { \"kernelPreference\": { \"name\": \"julia-1.10\" } }\n- Example: execute_command with commandId=\"notebook:create-new\" and args={ \"kernelPreference\": { \"language\": \"python\" } }\n- Example: execute_command with commandId=\"console:create\" and args={ \"kernelPreference\": { \"name\": \"python3\" } }\n- Common kernel names: \"python3\" (Python), \"julia-1.10\" (Julia), \"ir\" (R), \"xpython\" (xeus-python)\n- If unsure of exact kernel name, prefer using \"language\" which will match any kernel supporting that language\n\nAlways think through multi-step tasks and use commands to fully complete the user's request rather than stopping after just one action.\n\nYou are ready to help users build something great!"
    },
    "completionSystemPrompt": {
      "title": "Completion System Prompt",
      "description": "Instructions that define how the AI should generate code completions",
      "type": "string",
      "default": "You are an AI code completion assistant. Complete the given code fragment with appropriate code.\nRules:\n- Return only the completion text, no explanations or comments\n- Do not include code block markers (``` or similar)\n- Make completions contextually relevant to the surrounding code and notebook context\n- Follow the language-specific conventions and style guidelines for the detected programming language\n- Keep completions concise but functional\n- Do not repeat the existing code that comes before the cursor\n- Use variables, imports, functions, and other definitions from previous notebook cells when relevant"
    },
    "showCellDiff": {
      "title": "Show Cell Diff",
      "description": "Show diff view when AI modifies cell content",
      "type": "boolean",
      "default": true
    },
    "showFileDiff": {
      "title": "Show File Diff",
      "description": "Show diff view when AI modifies file content",
      "type": "boolean",
      "default": true
    },
    "diffDisplayMode": {
      "title": "Diff Display Mode",
      "description": "How to display cell diffs (split or unified view)",
      "type": "string",
      "enum": ["split", "unified"],
      "default": "split"
    },
    "skillsPaths": {
      "title": "Skills Paths",
      "description": "Paths to directories containing agent skills, relative to the server root. Skills are loaded from all paths; the first occurrence of a skill name takes priority.",
      "type": "array",
      "items": { "type": "string" },
      "default": [".agents/skills", "_agents/skills"]
    }
  },
  "additionalProperties": false
}
